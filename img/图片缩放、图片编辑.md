## 在图片选框范围内缩放图片  裁剪图片


```Java
import android.animation.ValueAnimator;
import android.app.Activity;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;

import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.target.Target;

import java.lang.ref.WeakReference;

/**
 * Created by lynn on 16/8/29.
 */
public class CropImgActivity extends BaseActivity implements View.OnClickListener {
    private static final String IMAGE_URL = "image_url";
    private static final String PIC_NAME = "pic_name";
    private static final String POS = "position";
    private String url = "";
    private ImageView imageView;
    private TouchListener onTouchListener;
    private CropLineView lines;
    private String name;
    private int position;
    private DialogUtil.LoadingDialog dialog;
    private ValueAnimator.AnimatorUpdateListener animatorUpdateListener = new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            onTouchListener.onLayoutChange((float) valueAnimator.getAnimatedValue());
        }
    };
    private RequestListener listener = new RequestListener<String, Drawable>() {
        @Override
        public boolean onException(Exception e, String model, Target<Drawable> target, boolean isFirstResource) {
            return false;
        }

        @Override
        public boolean onResourceReady(Drawable resource, String model, Target<Drawable> target, boolean isFromMemoryCache, boolean isFirstResource) {
            imageView.setImageDrawable(resource);
            onTouchListener.onLayoutChange(lines.getHeight());
            onTouchListener.onLayoutChange(lines.getHeight() + 0.1f);//don't know how to resolve it, just call it twice, will fix it after
            return true;
        }
    };

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_crop_img);
        getSupportActionBar().hide();
        url = getIntent().getStringExtra(IMAGE_URL);
        if (TextUtils.isEmpty(url)) {
            finish();
        }
        dialog = DialogUtil.getLoadingDialog(this);
        imageView = (ImageView) findViewById(R.id.image_view);
        lines = (CropLineView) findViewById(R.id.lines);
        name = getIntent().getStringExtra(PIC_NAME);
        position = getIntent().getIntExtra(POS, -1);
        ViewGroup.LayoutParams params = lines.getLayoutParams();
        params.height = Utils.getScreenWidth() * 9 / 16;
        lines.setLayoutParams(params);
        getPageView(url);
        initListener();
    }


    private View getPageView(String path) {
        imageView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
        imageView.setDrawingCacheEnabled(true);
        onTouchListener = new TouchListener(lines, imageView);
        imageView.setOnTouchListener(onTouchListener);
        ImageUtils.loadImg(url, imageView, listener);
        return imageView;
    }

    private void initListener() {
        findViewById(R.id.style_1_1).setOnClickListener(this);
        findViewById(R.id.style_3_2).setOnClickListener(this);
        findViewById(R.id.style_3_4).setOnClickListener(this);
        findViewById(R.id.style_4_3).setOnClickListener(this);
        findViewById(R.id.style_16_9).setOnClickListener(this);
        findViewById(R.id.reset).setOnClickListener(this);
        findViewById(R.id.complete).setOnClickListener(this);
        findViewById(R.id.cancel).setOnClickListener(this);
    }

    @Override
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.style_1_1:
                lines.setStyle(CropImgStyle.STYLE_1_1, animatorUpdateListener);
                break;
            case R.id.style_3_2:
                lines.setStyle(CropImgStyle.STYLE_3_2, animatorUpdateListener);
                break;
            case R.id.style_3_4:
                lines.setStyle(CropImgStyle.STYLE_3_4, animatorUpdateListener);
                break;
            case R.id.style_4_3:
                lines.setStyle(CropImgStyle.STYLE_4_3, animatorUpdateListener);
                break;
            case R.id.style_16_9:
                lines.setStyle(CropImgStyle.STYLE_16_9, animatorUpdateListener);
                break;
            case R.id.complete:
                dialog.show();
                saveFile();
                dialog.dismiss();
                break;
            case R.id.reset:
                onTouchListener.reset();
                onTouchListener.reset();
                break;
            case R.id.cancel:
                finish();
                break;
            default:
                break;
        }
    }

    /**
     * 将所截取图形保存为文件//TODO 大图加载优化
     */
    private void saveFile() {
        int[] location = new int[2];
        lines.getLocationInWindow(location);
        int y = location[1];
        Bitmap bitmap = ((GlideBitmapDrawable) imageView.getDrawable()).getBitmap();
        int bw = bitmap.getWidth();
        int bh = bitmap.getHeight();
        Matrix matrix = new Matrix();
        matrix.set(imageView.getImageMatrix());
        RectF rect = new RectF(0, 0, bw, bh);
        matrix.mapRect(rect);
        float[] m = new float[9];
        matrix.getValues(m);
        float scale = (rect.right - rect.left) / bw;
        Bitmap scaled = Bitmap.createScaledBitmap(bitmap, (int) (bw * scale), (int) (bh * scale), true);
        int startX = (int) (rect.left < 0 ? -rect.left : rect.left);
        int startY = (int) (y - rect.top - Utils.getStatusBarHeight());
        startY = startY < 0 ? -startY : startY;
        int endX = startX + lines.getWidth();
        int sw = scaled.getWidth();
        int sh = scaled.getHeight();
        endX = endX > sw ? sw - startX : endX - startX;
        int endY = startY + lines.getHeight();
        endY = endY > sh ? sh - startY : endY - startY;

        Bitmap terminal = Bitmap.createBitmap(scaled, startX, startY, endX, endY);
        ImageUtils.bitmapToFile(Utils.getImageCachePath() + "/" + name, terminal);
        scaled.recycle();
        terminal.recycle();
        OnImageEdited edited = new OnImageEdited();
        ImageBean b = new ImageBean();
        b.path = Utils.getImageCachePath() + "/" + (TextUtils.isEmpty(name) ? Utils.getCacheImgName() : name);
        edited.bean = b;
        edited.position = position;
        EventBus.getDefault().dispatch(edited);
        setResult(RESULT_OK);
        finish();
    }

    private static class TouchListener implements View.OnTouchListener {
        private static final int NONE = 0;
        private static final int DRAG = 1;
        private static final int ZOOM = 2;

        private int mode = NONE;
        private float oldDist;
        private Matrix matrix;
        private Matrix savedMatrix = new Matrix();
        private PointF start = new PointF();
        private PointF mid = new PointF();
        Bitmap bitmap;
        float minScaleR = 0.1f;  //最少缩放比例
        static final float MAX_SCALE = 4f; //最大缩放比例
        private WeakReference<ImageView> view;
        private WeakReference<CropLineView> line;

        public TouchListener(CropLineView lines, ImageView imageView) {
            view = new WeakReference<ImageView>(imageView);
            line = new WeakReference<CropLineView>(lines);
        }

        boolean firstEnter = true;

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            if (null == view || null == view.get()) return false;
            if (firstEnter) {
                view.get().setScaleType(ImageView.ScaleType.MATRIX);
                if (matrix == null) {
                    matrix = new Matrix();
                    matrix.set(view.get().getImageMatrix());
                }
            }
            switch (event.getAction() & MotionEvent.ACTION_MASK) {
                case MotionEvent.ACTION_DOWN:
                    savedMatrix.set(matrix);
                    start.set(event.getX(), event.getY());
                    mode = DRAG;
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_POINTER_UP:
                    mode = NONE;
                    break;
                case MotionEvent.ACTION_POINTER_DOWN:
                    oldDist = spacing(event);
                    if (oldDist > 10f) {
                        savedMatrix.set(matrix);
                        midPoint(mid, event);
                        mode = ZOOM;
                    }
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (mode == DRAG) {
                        matrix.set(savedMatrix);
                        matrix.postTranslate(event.getX() - start.x, event.getY() - start.y);
                    } else if (mode == ZOOM) {
                        float newDist = spacing(event);
                        if (newDist > 10f) {
                            matrix.set(savedMatrix);
                            float scale = newDist / oldDist;
                            matrix.postScale(scale, scale, mid.x, mid.y);
                        }
                    }
                    break;
            }
            view.get().setImageMatrix(matrix);
            checkScale();
            center();
            return true;
        }

        /**
         * 在网格发生大小变化时动态改变图片大小
         *
         * @param height
         */
        public void onLayoutChange(float height) {
            if (firstEnter) {
                view.get().setScaleType(ImageView.ScaleType.MATRIX);
                if (null == matrix) {
                    matrix = new Matrix();
                    matrix.set(view.get().getImageMatrix());
                }
                firstEnter = false;
                savedMatrix.set(matrix);
            }
            int[] location = new int[2];
            line.get().getLocationInWindow(location);
            Bitmap bitmap = ((GlideBitmapDrawable) view.get().getDrawable()).getBitmap();
            RectF rect = new RectF(0, 0, bitmap.getWidth(), bitmap.getHeight());
            matrix.mapRect(rect);
            float top = rect.top;
            float linesTop = (Utils.getScreenHeight() - Utils.getStatusBarHeight() - Utils.dip2px(100) - height) / 2;
            if (rect.height() < height || top > linesTop) {
                savedMatrix.set(matrix);
                view.get().setImageMatrix(matrix);
                checkScale();
                //分别对应actionDown actionmove actionup 防止图片闪烁
                center();
                center();
                center();
            }
        }

        /**
         * 点击重置
         */
        public void reset() {
            Bitmap bitmap = ((GlideBitmapDrawable) view.get().getDrawable()).getBitmap();
            RectF rect = new RectF(0, 0, bitmap.getWidth(), bitmap.getHeight());
            matrix.mapRect(rect);
            float lw = line.get().getWidth();
            float lh = line.get().getHeight();
            float scale = 1.0f;
            if (lw < rect.width()) {
                scale = lh / rect.height();
            } else {
                scale = lw / rect.width();
            }
            matrix.postScale(scale, scale);
            savedMatrix.set(matrix);
            view.get().setImageMatrix(matrix);
            checkScale();
            center();
            center();
        }

        /**
         * 检查缩放限制
         */
        protected void checkScale() {
            float p[] = new float[9];
            matrix.getValues(p);
            if (mode == ZOOM) {
                if (p[0] < minScaleR) {
                    matrix.setScale(minScaleR, minScaleR);
                }
                if (p[0] > MAX_SCALE) {
                    matrix.set(savedMatrix);
                }
            }
        }

        private float spacing(MotionEvent event) {
            float x = event.getX(0) - event.getX(1);
            float y = event.getY(0) - event.getY(1);
            return (float) Math.sqrt(x * x + y * y);
        }

        private void midPoint(PointF point, MotionEvent event) {
            float x = event.getX(0) + event.getX(1);
            float y = event.getY(0) + event.getY(1);
            point.set(x / 2, y / 2);
        }

        private synchronized void center() {//加锁防止数据错乱,notice this has risk
            if (null == line || null == line.get()) return;
            center(true, true);
        }

        /**
         * 居中,会将图片规定在网格中
         *
         * @param horizontal
         * @param vertical
         */
        private void center(boolean horizontal, boolean vertical) {
            Matrix m = new Matrix();
            m.set(matrix);
            try {
                bitmap = ((GlideBitmapDrawable) view.get().getDrawable()).getBitmap();
            } catch (Exception e) {
                e.printStackTrace();
                return;
            }
            RectF rect = new RectF(0, 0, bitmap.getWidth(), bitmap.getHeight());
            m.mapRect(rect);
            float height = rect.height();
            float width = rect.width();
            float deltaX = 0, deltaY = 0;
            int location[] = new int[2];
            line.get().getLocationInWindow(location);

            int lineTop = location[1] - Utils.getStatusBarHeight();
            int linesHeight = line.get().getHeight();
            int lineWidth = line.get().getWidth();
            if (width / lineWidth >= height / linesHeight) {
                horizontal = false;
                if (height < linesHeight) {
                    matrix.postScale(linesHeight / height, linesHeight / height);
                }
            } else {
                vertical = false;
                if (width < lineWidth) {
                    matrix.postScale(lineWidth / width, lineWidth / width);
                }
            }
            if (vertical) {
                if (height < linesHeight) {
                    deltaY = (linesHeight - height) / 2 - rect.top;
                } else if (rect.top > lineTop) {
                    deltaY = lineTop - rect.top;
                } else if (rect.bottom < lineTop + linesHeight) {
                    deltaY = lineTop + linesHeight - rect.bottom;
                }
            } else {
                if (rect.top > lineTop) {
                    deltaY = lineTop - rect.top;
                } else if (rect.bottom < lineTop + linesHeight) {
                    deltaY = lineTop + linesHeight - rect.bottom;
                }
            }

            if (horizontal) {
                if (width < lineWidth) {
                    deltaX = (lineWidth - width) / 2 - rect.left;
                } else if (rect.left > 0) {
                    deltaX = -rect.left;
                } else if (rect.right < lineWidth) {
                    deltaX = lineWidth - rect.right;
                }
            } else {
                if (rect.left > 0) {
                    deltaX = -rect.left;
                } else if (rect.right < line.get().getWidth()) {
                    deltaX = line.get().getWidth() - rect.right;
                }
            }
            matrix.postTranslate(deltaX, deltaY);
        }
    }

    public static void startActivity(Activity activity, String url, int requestCode, String picName, int position) {
        Intent intent = new Intent(activity, CropImgActivity.class);
        intent.putExtra(IMAGE_URL, url);
        intent.putExtra(PIC_NAME, picName);
        intent.putExtra(POS, position);
        activity.startActivityForResult(intent, requestCode);
    }
}
```java


```Java

import android.animation.ObjectAnimator;
import android.animation.ValueAnimator;
import android.annotation.TargetApi;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.os.Build;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.DecelerateInterpolator;

/**
 * Created by lynn on 16/8/29.
 * 截取图片时的网格
 */
public class CropLineView extends View {

    public CropLineView(Context context) {
        this(context, null);
    }

    public CropLineView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public CropLineView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public CropLineView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        init();
    }

    private static final int LINE = Utils.dip2px(1);
    private static final int CIRCLE = Utils.dip2px(2);
    private static final int SHORT_LINE = Utils.dip2px(20);
    private Paint paint;
    private int height;

    private void init() {
        paint = new Paint();
        paint.setColor(getResources().getColor(R.color.white));
        paint.setStyle(Paint.Style.FILL);
        paint.setAntiAlias(true);
    }

    public void setStyle(int style, ValueAnimator.AnimatorUpdateListener listener) {
        switch (style) {
            case CropImgStyle.STYLE_1_1:
                height = Utils.getScreenWidth();
                break;
            case CropImgStyle.STYLE_3_2:
                height = Utils.getScreenWidth() * 2 / 3;
                break;
            case CropImgStyle.STYLE_3_4:
                height = Utils.getScreenWidth() * 4 / 3;
                break;
            case CropImgStyle.STYLE_4_3:
                height = Utils.getScreenWidth() * 3 / 4;
                break;
            default:
                height = Utils.getScreenWidth() * 9 / 16;
                break;
        }
        startAnimator(listener);
    }

    private ObjectAnimator animator;
    private ViewGroup.LayoutParams params;

    private void startAnimator(ValueAnimator.AnimatorUpdateListener listener) {
        clearAnimation();
        animator = ObjectAnimator.ofFloat(this, "height", getHeight(), height);
        animator.setInterpolator(new DecelerateInterpolator());
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                params = getLayoutParams();
                params.height = ((int) (float) valueAnimator.getAnimatedValue());
                setLayoutParams(params);
                requestLayout();
            }
        });
        if (null != listener) {
            animator.addUpdateListener(listener);
        }
        animator.setDuration(500);
        animator.start();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        paint.setStrokeWidth(CIRCLE);
        int halfCircle = CIRCLE / 2;
        canvas.drawLine(0, halfCircle, getWidth(), halfCircle, paint); //up 线条
        canvas.drawLine(getWidth() - halfCircle, 0, getWidth() - halfCircle, getHeight(), paint);//right 线条
        canvas.drawLine(0, getHeight() - halfCircle, getWidth(), getHeight() - halfCircle, paint);//bottom 线条
        canvas.drawLine(halfCircle, 0, halfCircle, getHeight(), paint);//left 线条

        halfCircle = halfCircle * 3;
        //left - top
        canvas.drawLine(0, halfCircle, SHORT_LINE, halfCircle, paint);//top
        canvas.drawLine(halfCircle, 0, halfCircle, SHORT_LINE, paint);//left

        //right - top
        canvas.drawLine(getWidth() - halfCircle, 0, getWidth() - halfCircle, SHORT_LINE, paint);//right
        canvas.drawLine(getWidth() - SHORT_LINE, halfCircle, getWidth(), halfCircle, paint);//top

        //left - bottom
        canvas.drawLine(0, getHeight() - halfCircle, SHORT_LINE, getHeight() - halfCircle, paint);//bottom
        canvas.drawLine(halfCircle, getHeight() - SHORT_LINE, halfCircle, getHeight(), paint);//left

        //right - bottom
        canvas.drawLine(getWidth() - halfCircle, getHeight() - SHORT_LINE, getWidth() - halfCircle, getHeight(), paint);//right
        canvas.drawLine(getWidth() - SHORT_LINE, getHeight() - halfCircle, getWidth(), getHeight() - halfCircle, paint);//bottom

        paint.setStrokeWidth(LINE);
        //first - top
        canvas.drawLine(0, getHeight() / 3, getWidth(), getHeight() / 3, paint);
        //second - top
        canvas.drawLine(0, getHeight() * 2 / 3, getWidth(), getHeight() * 2 / 3, paint);
        //first - left
        canvas.drawLine(getWidth() / 3, 0, getWidth() / 3, getHeight(), paint);
        //second - left
        canvas.drawLine(getWidth() * 2 / 3, 0, getWidth() * 2 / 3, getHeight(), paint);
    }
}
```Java
